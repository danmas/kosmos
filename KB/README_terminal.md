# Терминал в Kosmos Panel (xterm.js + Node.js + AI)

Этот документ описывает архитектуру и принципы работы встроенного терминала, его взаимодействие с бэкендом по WebSocket и интеграцию с AI-помощником.

## Обзор

Терминал — одна из ключевых функций Kosmos Panel. Он предоставляет полноценный интерактивный SSH-доступ к удаленным серверам прямо из браузера.

**Основные технологии:**
- **Frontend**: [Xterm.js](https://xtermjs.org/) для эмуляции терминала в браузере.
- **Backend**: Node.js, модуль `ws` для WebSocket-сервера и `ssh2` для управления SSH-сессиями.
- **Коммуникация**: Все взаимодействие между клиентом и сервером происходит по протоколу WebSocket.

## Архитектура

### Frontend (`web/`)

Логика терминала на стороне клиента реализована в нескольких файлах:

1.  **`web/app.js`**:
    - Управляет созданием, отображением и уничтожением терминалов как в плавающих окнах на главной странице, так и в отдельной вкладке.
    - Инициализирует инстанс `Xterm.js` с аддонами (`FitAddon` для масштабирования).
    - Устанавливает WebSocket-соединение с бэкендом.
    - Обрабатывает входящие сообщения от сервера и выводит данные в терминал.
    - Отправляет пользовательский ввод на сервер.

2.  **`web/term.html`**:
    - Автономная страница для отображения терминала в полноэкранном режиме (в отдельной вкладке браузера).
    - Загружает `app.js`, который выполняет всю основную работу по инициализации.
    - Получает параметры (например, `serverId`) из URL query string.

### Backend (`server/`)

Серверная часть терминала находится в файле `server/ws.js`.

1.  **WebSocket-сервер**:
    - Принимает подключения по эндпоинту `/ws/terminal`.
    - Для каждого подключения создает новый инстанс SSH-клиента (`ssh2`).

2.  **SSH-сессия (`ssh2`)**:
    - После успешного подключения к удаленному серверу, создается pseudo-terminal (pty).
    - Весь ввод от пользователя (полученный по WS) перенаправляется в `stdin` pty.
    - Все данные из `stdout` и `stderr` pty перехватываются и отправляются клиенту по WS.
    - Сессия автоматически завершается при закрытии WebSocket-соединения или при ошибке SSH.

3.  **Логирование терминальных команд**:
    - Все взаимодействия с терминалом записываются в `terminal_log.json`.
    - Записи связываются через уникальные ID для отслеживания цепочки: AI запрос → команда → результат.
    - Поддерживается интерактивная панель лога и отдельная страница просмотра логов.

## Протокол WebSocket

Взаимодействие между клиентом и сервером строится на обмене JSON-сообщениями.

**Эндпоинт**: `/ws/terminal?serverId=<ID>&cols=<N>&rows=<M>`

### Клиент → Сервер

- **Пользовательский ввод**:
  ```json
  { "type": "data", "data": "..." }
  ```
  Отправляется, когда пользователь вводит символы в терминал.

- **Изменение размера окна**:
  ```json
  { "type": "resize", "cols": 120, "rows": 30 }
  ```
  Отправляется при изменении размера окна терминала, чтобы pty на сервере изменил свои размеры.

- **Запрос к AI**:
  ```json
  { "type": "ai_query", "prompt": "покажи самые большие файлы" }
  ```
  Особый тип сообщения для интеграции с ИИ. Отправляется вместо `"data"`, если ввод начинается с AI-префикса.

- **Логирование команд**:
  ```json
  { "type": "command_log", "command": "ls -la" }
  ```
  Отправляется для записи обычных (не AI) команд в лог терминала.

- **Закрытие соединения**:
  Не требует специального сообщения. Простое закрытие TCP-сокета со стороны клиента инициирует закрытие SSH-сессии на сервере.

### Сервер → Клиент

- **Данные из pty**:
  ```json
  { "type": "data", "data": "..." }
  ```
  Содержит вывод из `stdout`/`stderr` удаленной команды.

- **Нефатальная ошибка**:
  ```json
  { "type": "err", "error": "Сообщение об ошибке" }
  ```
  Информационная ошибка, которая отображается в терминале, но не прерывает сессию.

- **Фатальная ошибка**:
  ```json
  { "type": "fatal", "error": "Не удалось подключиться по SSH" }
  ```
  Ошибка, после которой сессия считается завершенной. Клиент должен закрыть соединение.

## Интеграция с AI-помощником

AI-помощник позволяет преобразовывать запросы на естественном языке в shell-команды.

### Жизненный цикл AI-запроса

1.  **Перехват на клиенте (`web/app.js`)**:
    - Для терминала регистрируется специальный обработчик `attachCustomKeyEventHandler`.
    - Он срабатывает на каждое нажатие клавиши `Enter`.
    - Если строка ввода начинается с префикса `ai:` (настраивается в `.env` через `AI_COMMAND_PREFIX`), то вместо обычного сообщения `{ "type": "data" }` на сервер отправляется `{ "type": "ai_query" }`.

2.  **Обработка на сервере (`server/ws.js`)**:
    - Сервер получает сообщение `{ "type": "ai_query" }`.
    - **Обратная связь**: Немедленно отправляет клиенту сообщение с текстом `Запрос к AI: ...`, чтобы пользователь видел, что его команда обрабатывается.
    - **Очистка ввода**: Отправляет в pty управляющий символ `\x15` (Ctrl+U), который стирает введенную пользователем команду `ai: ...` из строки терминала.
    - **Сбор контекста (RAG)**:
        - Система пытается прочитать локальный файл знаний (`./.kosmos/README_kosmos_server.md`).
        - Затем по текущему SSH-соединению выполняется команда `cat ~/.kosmos/README_kosmos.md` для получения сервер-специфичного контекста.
        - Содержимое этих файлов (если они существуют) добавляется к системному промпту.
    - **Вызов AI API**:
        - Формируется полный промпт, включающий системные инструкции, собранный контекст и запрос пользователя.
        - Отправляется HTTP-запрос к AI-серверу (URL, модель и другие параметры берутся из `.env`).
    - **Выполнение команды**:
        - Полученный от AI ответ (предполагается, что это готовая shell-команда) записывается в pty.
        - Команда отправляется в pty с добавлением `\n` в конце, что эмулирует нажатие `Enter` и немедленно запускает ее на выполнение.
    - **Логирование**:
        - Все AI запросы, команды и их результаты записываются в `terminal_log.json`.
        - Записи связываются через уникальные ID: `ai_query_id` в stdin записях, `stdin_id` в stdout записях.
        - Это позволяет отследить полную цепочку: AI запрос → сгенерированная команда → результат выполнения.

## Система логирования

Kosmos Panel ведет детальный лог всех взаимодействий с терминалом в файле `terminal_log.json`.

### Структура записей лога

Каждая запись имеет следующие обязательные поля:
```json
{
  "id": "уникальный-uuid",
  "sessionId": "uuid-сессии", 
  "timestamp": "2025-08-25T08:35:50.762Z",
  "type": "тип-записи",
  "serverId": "идентификатор-сервера",
  "serverName": "название-сервера",
  "serverHost": "хост-сервера"
}
```

### Типы записей

1. **`ai_query`** - AI запрос пользователя:
   ```json
   {
     "type": "ai_query",
     "user_ai_query": "показать диски",
     "serverId": "usa",
     "serverName": "USA Server",
     "serverHost": "192.168.1.100"
   }
   ```

2. **`stdin`** - Выполненная команда:
   ```json
   {
     "type": "stdin", 
     "executed_command": "df -h",
     "ai_query_id": "uuid-ai-запроса",  // опционально
     "serverId": "usa",
     "serverName": "USA Server",
     "serverHost": "192.168.1.100"
   }
   ```

3. **`stdout`** - Результат выполнения:
   ```json
   {
     "type": "stdout",
     "terminal_output": "вывод команды",
     "stdin_id": "uuid-команды",
     "serverId": "usa",
     "serverName": "USA Server",
     "serverHost": "192.168.1.100"
   }
   ```

4. **`stderr`** - Ошибки:
   ```json
   {
     "type": "stderr", 
     "terminal_output": "текст ошибки",
     "stdin_id": "uuid-команды",
     "serverId": "usa",
     "serverName": "USA Server", 
     "serverHost": "192.168.1.100"
   }
   ```

### Связи между записями

- **`ai_query_id`** в stdin записях - связь с AI запросом, который сгенерировал команду
- **`stdin_id`** в stdout/stderr записях - связь с командой, которая дала этот вывод

### Интерфейсы просмотра логов

1. **Интерактивная панель** (`/term.html`) - показывает лог для текущей команды при наведении
2. **Страница логов** (`/logs.html`) - полный просмотр с группировкой связанных записей и фильтрацией по серверам
3. **Raw JSON** (`/raw-logs.html`) - просмотр исходного JSON файла

## Как вносить изменения

- **Добавить новую фичу в UI терминала**:
  - Основная логика находится в `web/app.js` в функциях, связанных с `openTerminal` и `setupTerminal`.
  - Для изменения поведения ввода смотрите `attachCustomKeyEventHandler`.

- **Изменить логику AI-обработки**:
  - Вся серверная логика находится в `server/ws.js` внутри обработчика сообщений от WebSocket.
  - Ищите блок `if (msg.type === 'ai_query')`. Здесь можно изменить способ сбора контекста, параметры вызова AI или обработку ответа.

- **Расширить протокол WebSocket**:
  - При добавлении нового `type` сообщения не забудьте реализовать его обработку как на клиенте (`web/app.js`), так и на сервере (`server/ws.js`).
  - Старайтесь не изменять семантику существующих типов сообщений, чтобы не нарушить обратную совместимость.
