<!doctype html>
<html lang="ru">
  <head>
    <meta charset="utf-8" />
    <title>Terminal</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" href="https://unpkg.com/xterm/css/xterm.css" />
    <script src="https://unpkg.com/xterm/lib/xterm.js"></script>
    <script src="https://unpkg.com/xterm-addon-fit/lib/xterm-addon-fit.js"></script>
    <style>
      html, body { height:100%; margin:0; background:#0b0f1a; color:#e6ecff; }
      .wrap { height:100%; display:flex; flex-direction:column; }
      .top { padding:8px 10px; background:#0e1322; border-bottom:1px solid #1c2333; display:flex; gap:8px; align-items:center; }
      .title { font-weight:700; }
      .term { flex:1; background:#000; }
      .bar { padding:6px 10px; background:#0e1322; border-top:1px solid #1c2333; display:flex; gap:8px; }
      button { background:#1b2544; border:1px solid #223055; color:#e6ecff; border-radius:8px; padding:6px 10px; cursor:pointer; }
      .term-container { position: relative; flex: 1; display: flex; }
      .term { flex: 1; background: #000; }
      .log-indicator {
        position: absolute;
        top: 10px;
        right: 10px;
        width: 24px;
        height: 24px;
        background: #1b2544;
        border: 1px solid #223055;
        border-radius: 50%;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 12px;
        opacity: 0.7;
        transition: opacity 0.2s;
        z-index: 10;
      }
      .log-indicator:hover { opacity: 1; }
      .log-indicator.active { background: #2d4a87; opacity: 1; }
      .log-panel {
        position: absolute;
        top: 0;
        right: 0;
        width: 400px;
        height: 100%;
        background: #0e1322;
        border-left: 1px solid #1c2333;
        transform: translateX(100%);
        transition: transform 0.3s ease;
        z-index: 1000;
        display: flex;
        flex-direction: column;
      }
      .log-panel.visible { transform: translateX(0); }
      .log-header {
        padding: 8px 12px;
        background: #1b2544;
        border-bottom: 1px solid #223055;
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-size: 13px;
        font-weight: 600;
      }
      .log-content {
        flex: 1;
        padding: 12px;
        overflow-y: auto;
        font-family: 'Courier New', monospace;
        font-size: 12px;
        line-height: 1.4;
      }
      .log-entry { margin-bottom: 16px; }
      .log-entry-type {
        color: #4a9eff;
        font-weight: 600;
        margin-bottom: 4px;
      }
      .log-entry-content {
        background: #0b0f1a;
        padding: 8px;
        border-radius: 4px;
        border-left: 3px solid #4a9eff;
        white-space: pre-wrap;
        word-break: break-all;
      }
      .log-ai-query { border-left-color: #ffa500; }
      .log-stdin { border-left-color: #00ff00; }
      .log-stdout { border-left-color: #4a9eff; }
    </style>
  </head>
  <body>
    <div class="wrap">
      <div class="top"><div class="title" id="t"></div><button id="close">–ó–∞–∫—Ä—ã—Ç—å</button></div>
      <div class="term-container">
        <div id="term" class="term"></div>
        <div class="log-indicator" id="logIndicator" title="–ü–æ–∫–∞–∑–∞—Ç—å –ª–æ–≥ –∫–æ–º–∞–Ω–¥—ã">üìã</div>
        <div class="log-panel" id="logPanel">
          <div class="log-header">
            <span>–õ–æ–≥ –∫–æ–º–∞–Ω–¥—ã</span>
            <button onclick="hideLogPanel()" style="background:none;border:none;color:#e6ecff;cursor:pointer;">‚úï</button>
          </div>
          <div class="log-content" id="logContent">
            <div style="color: #888; text-align: center; margin-top: 50px;">
              –ù–∞–≤–µ–¥–∏—Ç–µ –∫—É—Ä—Å–æ—Ä –Ω–∞ –∫–æ–º–∞–Ω–¥—É –≤ —Ç–µ—Ä–º–∏–Ω–∞–ª–µ
            </div>
          </div>
        </div>
      </div>
      <div class="bar"><button id="fit">–ü–æ–¥–æ–≥–Ω–∞—Ç—å</button></div>
    </div>
    <script>
      const params = new URLSearchParams(location.search);
      const mode = params.get('mode');
      const serverId = params.get('serverId');
      const path = params.get('path') || '';
      const title = document.getElementById('t');
      title.textContent = mode === 'tail' ? `tail ${path}` : `terminal (${serverId})`;
      const termDiv = document.getElementById('term');
      const term = new Terminal({ convertEol:true, cursorBlink:true, theme:{ background:'#000000', foreground:'#00ff00' } });
      
      const fit = new window.FitAddon.FitAddon();
      term.loadAddon(fit); term.open(termDiv); setTimeout(()=>{ try{fit.fit()}catch{} },0);
      const wsProto = location.protocol === 'https:' ? 'wss' : 'ws';
      const wsUrl = mode === 'tail'
        ? `${wsProto}://${location.host}/ws/tail?serverId=${encodeURIComponent(serverId)}&path=${encodeURIComponent(path)}&lines=200`
        : `${wsProto}://${location.host}/ws/terminal?serverId=${encodeURIComponent(serverId)}&cols=120&rows=30`;
      const ws = new WebSocket(wsUrl);
      term.writeln(mode === 'tail' ? `[tail ${path}]` : '[–ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ SSH...]');
      ws.onopen = () => term.writeln('[—Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ]');
      ws.onmessage = ev => { try { const m = JSON.parse(ev.data); if (m.type==='data'||m.type==='err') term.write(m.data); if (m.type==='fatal') term.writeln(`\r\n[FATAL] ${m.error}`); } catch {} };
      ws.onclose = ev => term.writeln(`\r\n[—Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –∑–∞–∫—Ä—ã—Ç–æ${ev.code ? ' –∫–æ–¥ ' + ev.code : ''}]`);
      
      let aiCommandPrefix = 'ai:';

      fetch('/api/config')
        .then(res => res.json())
        .then(config => {
          if (config.aiCommandPrefix) {
            aiCommandPrefix = config.aiCommandPrefix;
          }
        })
        .catch(err => console.error('Failed to fetch AI config:', err));
        
      if (mode !== 'tail') {
        term.onData(d => { try { ws.send(JSON.stringify({ type:'data', data:d })); } catch {} });
        
        term.attachCustomKeyEventHandler((arg) => {
          if (arg.code === 'Enter' && arg.type === 'keydown') {
            const buffer = term.buffer.active;
            
            // –ò—â–µ–º –ø–æ—Å–ª–µ–¥–Ω—é—é —Å—Ç—Ä–æ–∫—É —Å shell prompt
            for (let i = buffer.length - 1; i >= 0; i--) {
              const line = buffer.getLine(i).translateToString(true);
              const promptEndIndex = Math.max(line.lastIndexOf('$'), line.lastIndexOf('#'), line.lastIndexOf('>'));

              if (promptEndIndex !== -1) {
                const commandPart = line.substring(promptEndIndex);
                
                const prefixText = aiCommandPrefix.slice(0, -1);
                const prefixSep = aiCommandPrefix.slice(-1);
                const commandRegex = new RegExp(`(${prefixText}\\s*${prefixSep})`);
                
                const match = commandPart.match(commandRegex);

                if (match) {
                  const aiPrompt = commandPart.substring(match.index + match[0].length).trim();
                  term.write('\r\n\x1b[1;33m–ó–∞–ø—Ä–æ—Å –∫ AI: ' + aiPrompt + '\x1b[0m\r\n');
                  
                  ws.send(JSON.stringify({ type: 'ai_query', prompt: line }));
                  return false; // –ë–ª–æ–∫–∏—Ä—É–µ–º —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—É—é –æ—Ç–ø—Ä–∞–≤–∫—É Enter
                }
              }
              
              // –ï—Å–ª–∏ –Ω–∞—à–ª–∏ shell prompt –±–µ–∑ ai: - –æ—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º—Å—è
              if (promptEndIndex !== -1) {
                break;
              }
            }
          }
          return true; // –†–∞–∑—Ä–µ—à–∞–µ–º –≤—Å–µ –æ—Å—Ç–∞–ª—å–Ω—ã–µ –∫–ª–∞–≤–∏—à–∏
        });
      }

      document.getElementById('close').onclick = () => { try { ws.close(); } catch {}; window.close(); };
      document.getElementById('fit').onclick = () => { try { fit.fit(); } catch {} };

      // –ñ–¥–µ–º –ø–æ–ª–Ω–æ–π –∑–∞–≥—Ä—É–∑–∫–∏ DOM
      setTimeout(() => {
        initializeLogPanel();
      }, 100);

      let currentLogEntries = [];
      let logPanelVisible = false;

      function initializeLogPanel() {
        console.log('[DEBUG] –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø–∞–Ω–µ–ª–∏ –ª–æ–≥–∞');
        const indicator = document.getElementById('logIndicator');
        if (!indicator) {
          console.error('[DEBUG] –≠–ª–µ–º–µ–Ω—Ç logIndicator –Ω–µ –Ω–∞–π–¥–µ–Ω!');
          return;
        }
        console.log('[DEBUG] –≠–ª–µ–º–µ–Ω—Ç logIndicator –Ω–∞–π–¥–µ–Ω:', indicator);
        
        // –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏
        setupLogIndicatorClick();
        setupHoverEvents();
      }

      // –ó–∞–≥—Ä—É–∂–∞–µ–º –ª–æ–≥
      async function loadTerminalLog() {
        try {
          const response = await fetch('/terminal_log.json');
          // cache bust
          const response2 = await fetch('/terminal_log.json?t=' + Date.now());
          return await response2.json();
        } catch (err) {
          console.error('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –ª–æ–≥–∞:', err);
          return [];
        }
      }

      // –ü–æ–∏—Å–∫ –∫–æ–º–∞–Ω–¥—ã –ø–æ–¥ –∫—É—Ä—Å–æ—Ä–æ–º
      function findCommandAtCursor(term, row) {
        const buffer = term.buffer.active;
        console.log(`[DEBUG] –ò—â–µ–º –∫–æ–º–∞–Ω–¥—É –≤ —Å—Ç—Ä–æ–∫–µ ${row}, –¥–ª–∏–Ω–∞ –±—É—Ñ–µ—Ä–∞: ${buffer.length}`);
        
        if (row < 0 || row >= buffer.length) {
          console.log(`[DEBUG] –°—Ç—Ä–æ–∫–∞ ${row} –≤–Ω–µ –¥–∏–∞–ø–∞–∑–æ–Ω–∞ –±—É—Ñ–µ—Ä–∞`);
          return null;
        }

        // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –∫–æ–Ω—Ç–µ–∫—Å—Ç - –Ω–µ—Å–∫–æ–ª—å–∫–æ —Å—Ç—Ä–æ–∫ –≤–æ–∫—Ä—É–≥
        console.log(`[DEBUG] –ö–æ–Ω—Ç–µ–∫—Å—Ç –±—É—Ñ–µ—Ä–∞:`);
        for (let k = Math.max(0, row - 3); k <= Math.min(buffer.length - 1, row + 3); k++) {
          const contextLine = buffer.getLine(k).translateToString(true);
          console.log(`[DEBUG] –°—Ç—Ä–æ–∫–∞ ${k}: "${contextLine}"`);
        }

        // –ò—â–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–π –ø—Ä–æ–º–ø—Ç –ø–µ—Ä–µ–¥ —Ç–µ–∫—É—â–µ–π —Å—Ç—Ä–æ–∫–æ–π
        for (let i = row; i >= 0; i--) {
          const line = buffer.getLine(i).translateToString(true);
          const promptEndIndex = Math.max(line.lastIndexOf('$'), line.lastIndexOf('#'), line.lastIndexOf('>'));

          console.log(`[DEBUG] –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ç—Ä–æ–∫—É ${i}: "${line}", promptEndIndex: ${promptEndIndex}`);

          if (promptEndIndex !== -1) {
            // –ù–∞—à–ª–∏ —Å—Ç—Ä–æ–∫—É —Å –ø—Ä–æ–º–ø—Ç–æ–º, –∏–∑–≤–ª–µ–∫–∞–µ–º –∫–æ–º–∞–Ω–¥—É
            let commandParts = [line.substring(promptEndIndex + 1).trim()];
            for (let j = i + 1; j <= row; j++) {
              commandParts.push(buffer.getLine(j).translateToString(true).trim());
            }
            const fullCommand = commandParts.join(' ').trim();
            
            // –£–±–∏—Ä–∞–µ–º ANSI-–∫–æ–¥—ã –∏ –ø—Ä–æ—á–∏–π –º—É—Å–æ—Ä
            const cleanCommand = fullCommand.replace(/\x1b\[[0-9;?]*[a-zA-Z]/g, '').replace(/[\b\u0007]/g, '');
            
            console.log(`[DEBUG] –ü–æ–ª–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞: "${fullCommand}"`);
            console.log(`[DEBUG] –û—á–∏—â–µ–Ω–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞: "${cleanCommand}"`);
            
            if (cleanCommand === '' && i === row) return ' '; 
            return cleanCommand || null;
          }
        }
        console.log(`[DEBUG] –ü—Ä–æ–º–ø—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω`);
        return null;
      }

      // –ü–æ–∏—Å–∫ –ø–æ—Å–ª–µ–¥–Ω–µ–π –∫–æ–º–∞–Ω–¥—ã –≤ –±—É—Ñ–µ—Ä–µ
      function findLastCommand(term) {
        const buffer = term.buffer.active;
        console.log(`[DEBUG] –ò—â–µ–º –ø–æ—Å–ª–µ–¥–Ω—é—é –∫–æ–º–∞–Ω–¥—É –≤ –±—É—Ñ–µ—Ä–µ, –¥–ª–∏–Ω–∞: ${buffer.length}`);
        
        // –ò—â–µ–º —Å –∫–æ–Ω—Ü–∞ –±—É—Ñ–µ—Ä–∞
        for (let i = buffer.length - 1; i >= 0; i--) {
          const line = buffer.getLine(i).translateToString(true);
          const promptEndIndex = Math.max(line.lastIndexOf('$'), line.lastIndexOf('#'), line.lastIndexOf('>'));
          
          if (promptEndIndex !== -1) {
            console.log(`[DEBUG] –ù–∞–π–¥–µ–Ω –ø—Ä–æ–º–ø—Ç –≤ —Å—Ç—Ä–æ–∫–µ ${i}: "${line}"`);
            
            // –ò–∑–≤–ª–µ–∫–∞–µ–º –∫–æ–º–∞–Ω–¥—É –ø–æ—Å–ª–µ –ø—Ä–æ–º–ø—Ç–∞
            const commandPart = line.substring(promptEndIndex + 1).trim();
            const cleanCommand = commandPart.replace(/\x1b\[[0-9;?]*[a-zA-Z]/g, '').replace(/[\b\u0007]/g, '');
            
            console.log(`[DEBUG] –ü–æ—Å–ª–µ–¥–Ω—è—è –∫–æ–º–∞–Ω–¥–∞: "${cleanCommand}"`);
            return cleanCommand || null;
          }
        }
        
        console.log('[DEBUG] –ü–æ—Å–ª–µ–¥–Ω–∏–π –ø—Ä–æ–º–ø—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω');
        return null;
      }

      // –ü–æ–∏—Å–∫ –∑–∞–ø–∏—Å–µ–π –≤ –ª–æ–≥–µ –¥–ª—è –∫–æ–º–∞–Ω–¥—ã
      function findLogEntriesForCommand(log, command) {
        if (!command) return [];
        command = command.trim();
        if (!command) return [];
        
        console.log(`[DEBUG] –ò—â–µ–º –∫–æ–º–∞–Ω–¥—É –≤ –ª–æ–≥–µ: "${command}"`);
        console.log(`[DEBUG] –í—Å–µ–≥–æ –∑–∞–ø–∏—Å–µ–π –≤ –ª–æ–≥–µ: ${log.length}`);
        
        const entries = [];
        
        // –ò—â–µ–º –ø–æ—Å–ª–µ–¥–Ω—é—é stdin –∑–∞–ø–∏—Å—å —Å —Ç–∞–∫–æ–π –∫–æ–º–∞–Ω–¥–æ–π
        for (let i = log.length - 1; i >= 0; i--) {
          const entry = log[i];
          if (entry.type === 'stdin' && entry.executed_command) {
            console.log(`[DEBUG] –ü—Ä–æ–≤–µ—Ä—è–µ–º stdin –∑–∞–ø–∏—Å—å: "${entry.executed_command}" vs "${command}"`);
            if (entry.executed_command.trim() === command) {
              console.log(`[DEBUG] –ù–∞–π–¥–µ–Ω–∞ –ø–æ–¥—Ö–æ–¥—è—â–∞—è –∫–æ–º–∞–Ω–¥–∞!`);
              // –ù–∞—à–ª–∏ –∫–æ–º–∞–Ω–¥—É, —Ç–µ–ø–µ—Ä—å —Å–æ–±–∏—Ä–∞–µ–º –≤—Å–µ —Å–≤—è–∑–∞–Ω–Ω—ã–µ –∑–∞–ø–∏—Å–∏
              const sessionId = entry.sessionId;
              
              // –ò—â–µ–º ai_query –ø–µ—Ä–µ–¥ —ç—Ç–æ–π –∫–æ–º–∞–Ω–¥–æ–π
              if (entry.user_ai_query) {
                 for (let j = i - 1; j >= 0; j--) {
                  const prevEntry = log[j];
                  if (prevEntry.sessionId === sessionId && prevEntry.type === 'ai_query') {
                    if (prevEntry.user_ai_query === entry.user_ai_query) {
                      entries.unshift(prevEntry);
                      break;
                    }
                  }
                }
              }
              
              // –î–æ–±–∞–≤–ª—è–µ–º —Å–∞–º—É –∫–æ–º–∞–Ω–¥—É
              entries.push(entry);
              
              // –ò—â–µ–º stdout –ø–æ—Å–ª–µ –∫–æ–º–∞–Ω–¥—ã
              for (let j = i + 1; j < log.length; j++) {
                const nextEntry = log[j];
                if (nextEntry.sessionId === sessionId) {
                  if (nextEntry.type === 'stdout' || nextEntry.type === 'stderr') {
                    entries.push(nextEntry);
                  } else if (nextEntry.type === 'stdin') {
                    // –î–æ—à–ª–∏ –¥–æ —Å–ª–µ–¥—É—é—â–µ–π –∫–æ–º–∞–Ω–¥—ã, –æ—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º—Å—è
                    break;
                  }
                }
              }
              break; // –ù–∞—à–ª–∏ –ø–æ—Å–ª–µ–¥–Ω–µ–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ, –≤—ã—Ö–æ–¥–∏–º
            }
          }
        }
        
        console.log(`[DEBUG] –ù–∞–π–¥–µ–Ω–æ –∑–∞–ø–∏—Å–µ–π: ${entries.length}`);
        return entries;
      }


      // –û—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –ª–æ–≥–∞
      function displayLogEntries(entries) {
        const logContent = document.getElementById('logContent');
        
        if (entries.length === 0) {
          logContent.innerHTML = '<div style="color: #888; text-align: center; margin-top: 50px;">–õ–æ–≥ –¥–ª—è —ç—Ç–æ–π –∫–æ–º–∞–Ω–¥—ã –Ω–µ –Ω–∞–π–¥–µ–Ω</div>';
          return;
        }
        
        const html = entries.map(entry => {
          let typeLabel, content, className;
          
          switch (entry.type) {
            case 'ai_query':
              typeLabel = 'ü§ñ AI –ó–∞–ø—Ä–æ—Å';
              content = entry.user_ai_query;
              className = 'log-ai-query';
              break;
            case 'stdin':
              typeLabel = '‚ö° –ö–æ–º–∞–Ω–¥–∞';
              content = entry.executed_command;
              className = 'log-stdin';
              break;
            case 'stdout':
              typeLabel = 'üì§ –í—ã–≤–æ–¥';
              // –£–±–∏—Ä–∞–µ–º ANSI escape codes
              content = (entry.terminal_output || '').replace(/\x1b\[[0-9;?]*[a-zA-Z]/g, '');
              className = 'log-stdout';
              break;
            case 'stderr':
              typeLabel = 'üî• –û—à–∏–±–∫–∞';
              content = (entry.terminal_output || '').replace(/\x1b\[[0-9;?]*[a-zA-Z]/g, '');
              className = 'log-stderr'; // –ù—É–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å —Å—Ç–∏–ª—å
              break;
            default:
              return '';
          }
          
          // Basic HTML escaping
          content = content.replace(/</g, '&lt;').replace(/>/g, '&gt;');

          return `
            <div class="log-entry">
              <div class="log-entry-type">${typeLabel}</div>
              <pre class="log-entry-content ${className}">${content}</pre>
            </div>
          `;
        }).join('');
        
        logContent.innerHTML = html;
      }

      // –ü–æ–∫–∞–∑–∞—Ç—å/—Å–∫—Ä—ã—Ç—å –ø–∞–Ω–µ–ª—å
      function showLogPanel() {
        const panel = document.getElementById('logPanel');
        const indicator = document.getElementById('logIndicator');
        panel.classList.add('visible');
        indicator.classList.add('active');
        logPanelVisible = true;
      }

      function hideLogPanel() {
        const panel = document.getElementById('logPanel');
        const indicator = document.getElementById('logIndicator');
        panel.classList.remove('visible');
        indicator.classList.remove('active');
        logPanelVisible = false;
      }

      let lastHoveredRow = -1;
      let hoverTimeout = null;

      // –≠—Ç—É —Ñ—É–Ω–∫—Ü–∏—é –ø–µ—Ä–µ–º–µ—Å—Ç–∏–º –≤ initializeLogPanel
      function setupLogIndicatorClick() {
        const indicator = document.getElementById('logIndicator');
        if (indicator) {
          indicator.onclick = async () => {
            console.log('[DEBUG] –ö–ª–∏–∫ –Ω–∞ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä –ª–æ–≥–∞');
            if (logPanelVisible) {
              hideLogPanel();
            } else {
               showLogPanel();
               // –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –æ–±–Ω–æ–≤–∏–º –ª–æ–≥ –¥–ª—è —Ç–µ–∫—É—â–µ–π –ø–æ–∑–∏—Ü–∏–∏ –∫—É—Ä—Å–æ—Ä–∞
               updateLogForPosition(term.buffer.active.cursorY);
            }
          };
        }
      }

      async function updateLogForPosition(row) {
        console.log(`[DEBUG] updateLogForPosition –≤—ã–∑–≤–∞–Ω –¥–ª—è —Å—Ç—Ä–æ–∫–∏: ${row}`);
        if (isNaN(row) || row < 0) {
          console.log('[DEBUG] –ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–∞—è —Å—Ç—Ä–æ–∫–∞, –∏—Å–ø–æ–ª—å–∑—É–µ–º –ø–æ–∑–∏—Ü–∏—é –∫—É—Ä—Å–æ—Ä–∞');
          row = term.buffer.active.cursorY;
        }
        try {
          const log = await loadTerminalLog();
          let command = findCommandAtCursor(term, row);
          
          // –ï—Å–ª–∏ –∫–æ–º–∞–Ω–¥–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞, –∏—â–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–π –ø—Ä–æ–º–ø—Ç –≤ –±—É—Ñ–µ—Ä–µ
          if (!command) {
            console.log('[DEBUG] –ö–æ–º–∞–Ω–¥–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞, –∏—â–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–π –ø—Ä–æ–º–ø—Ç');
            command = findLastCommand(term);
          }
          
          console.log(`[DEBUG] –ù–∞–π–¥–µ–Ω–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞: "${command}"`);
          const entries = findLogEntriesForCommand(log, command);
          displayLogEntries(entries);
          if (!logPanelVisible && entries.length > 0) {
             // –ú–æ–∂–Ω–æ —Å–¥–µ–ª–∞—Ç—å –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä –∞–∫—Ç–∏–≤–Ω—ã–º, –µ—Å–ª–∏ –µ—Å—Ç—å –ª–æ–≥
          }
        } catch (error) {
          console.error('[DEBUG] –û—à–∏–±–∫–∞ –≤ updateLogForPosition:', error);
        }
      }

      function setupHoverEvents() {
        // –û–±—Ä–∞–±–æ—Ç–∫–∞ hover –Ω–∞–¥ —Ç–µ—Ä–º–∏–Ω–∞–ª–æ–º –¥–ª—è –∞–≤—Ç–æ–æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –ª–æ–≥–∞
        const termElement = term.element;
        if (termElement) {
          termElement.addEventListener('mousemove', (e) => {
            try {
              const charHeight = term._core._renderService.dimensions.actualCellHeight;
              if(charHeight <= 0) return;

              const terminalRect = termElement.getBoundingClientRect();
              const relativeY = e.clientY - terminalRect.top;
              const row = Math.floor(relativeY / charHeight) + term.buffer.active.viewportY;

              if (row !== lastHoveredRow && !isNaN(row)) {
                lastHoveredRow = row;
                if (hoverTimeout) clearTimeout(hoverTimeout);
                
                hoverTimeout = setTimeout(() => {
                  if (logPanelVisible) {
                     updateLogForPosition(row);
                  }
                }, 150); // –ó–∞–¥–µ—Ä–∂–∫–∞ –≤ 150ms
              }
            } catch (err) {
              console.error('[DEBUG] –û—à–∏–±–∫–∞ –≤ mousemove:', err);
            }
          });
          console.log('[DEBUG] Hover —Å–æ–±—ã—Ç–∏—è –Ω–∞—Å—Ç—Ä–æ–µ–Ω—ã');
        } else {
          console.error('[DEBUG] term.element –Ω–µ –Ω–∞–π–¥–µ–Ω!');
        }
      }
    </script>
  </body>
</html>


